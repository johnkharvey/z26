; cpu memory and register handlers -- used by the CPU emulator

;*
;* Process the timer...
;*

Timer1: movzx	dx,[RCycles]		; normal timer, decrements at 1 per
	sub	[Timer],dx		; processor cycle
Timer0:
	ret
					; this decs at various rates
Timer2: movzx	dx,[RCycles]		; subtract cycles from tickcount
	sub	[TickCnt],dx
	jl	DecTimer		; if its < 0,decrement the timer
	ret
DecTimer:
	mov	dx,[TRate]		; reset the tick counter
	add	[TickCnt],dx
	dec	[Timer]			; decrement the timer
	mov	dx,[Timer]
	cmp	dx,0FFFFh		; ticked round (on FFh bug fix)
	je	SetMode1		; if its zero count down in mode 1
	ret


;*
;* This is generated by writing to $0294 .. $0297, the RIOT timer regs
;* SI contains the address on entry. [WByte] is the timer value
;*

SetTimer:
	push	ax			; set the timer
	movzx	ax,[WByte]		; get the value to write
	mov	[Timer],ax		; and write it !
	pop	ax
	cmp	si,0294h		; is it the 1 clock timer
	je	SetMode1		; if so,go to mode 1

	push	ax			; it is the Mode n timer
	push	bx
	mov	bx,si			; work out the offset
	sub	bx,0295h
	add	bx,bx
	mov	ax,TimerCount[bx]	; get the counting value
	mov	[TRate],ax		; set the tick rate
	movzx	bx,[RCycles]
	add	ax,bx			; add the number of cycles for this inst
					; because after the write it'll be decd
	mov	[TickCnt],ax		; set the tick count
	mov	[TimerVec],offset Timer2; patch to call Timer2 routine
	pop	bx			; tidy up
	pop	ax
	ret

SetMode1:				; patch code to call the Timer1 routine
	mov	[TimerVec],offset Timer1
	ret


;*
;* Read bank switcher (SI contains the address accessed)
;*

RBank4: and	si,01fffh
	cmp	si,1000h		; if not ROM, read hardware
	jb	ReadHardware
	add	si,offset CartRom - 1000h
	ret
        
RBank8: and	si,01fffh
	cmp	si,1000h		; if not ROM, read hardware
	jb	ReadHardware
	cmp	si,1FF8h		; if not in switch area...
	jb	RBank8NoChange		; theres no change
	cmp	si,1FFAh
	ja	RBank8NoChange
	mov	[RomBank],0		; selected bank 0
	cmp	si,1FF8h
	je	RBank8NoChange
	mov	[RomBank],1000h		; selected bank 1
RBank8NoChange:
	add	si,[RomBank]
	add	si,offset CartRom - 1000h
	ret
        
ReadHardware:
	cmp	si,0200h		; is it the RIOT ???
	jge	ReadRIOT
ReadHardwarePage0:
	and	si,0FFh			; it must be the TIA or RAM
	cmp	si,080h			; is it the TIA ???
	jl	ReadTIA
	add	si,offset RiotRam-128	; point si to the riotram area
	ret
					        
RBank16: and	si,01fffh
	cmp	si,1000h		; if not ROM, read hardware
	jb	ReadHardware
	cmp	si,1FF6h		; if not in switch area...
	jb	RBank16NoChange		; theres no change
	cmp	si,1FFAh
	ja	RBank16NoChange

	push	ax			; 16k ROM switch
	mov	ax,si
	sub	ax,1FF6h		; its 0,1,2,3
	shl	ax,12			; its 0,4k,8k,12k
	mov	[RomBank],ax
	pop	ax

RBank16NoChange:
	add	si,[RomBank]
	add	si,offset CartRom - 1000h
	ret
        
; *****************************************************************************
;     Memory Mapping - Read - For non-rom areas, SI contains the requested
;	address. On exit ds:[si] points to the actual required data
; *****************************************************************************

ReadRIOT:
	and	si,02FFh		; riot at 2xx 3xx
	cmp	si,0284h		; is it the RIOT timer ???
	jne	NotRTimer
	mov	si,offset Timer		; make SI point to the timer
	ret
NotRTimer:				; all the other RIOT Registers
	cmp	si,0280h		; is it Port A (Hand Controllers) ?
	je	ReadPortA
	cmp	si,0282h		; is it Port B (Console Switches) ?
	je	ReadPortB
	mov	si,offset RetFF
	ret
ReadPortB:				; read console switches (port b)
	mov	si,offset IOPortB
	ret
ReadPortA:				; read hand controllers (port b)
	mov	si,offset IOPortA
	ret

ReadTIA:and	si,0Fh
	cmp	si,08h			; reading collision registers ???
	jl	ReadCollision
	cmp	si,0Eh
	jl	ReadInputLatches
	mov	si,offset Ret0F		; read the TIA (default)
	ret
        

ReadCollision:				; read the collision latch
	push	ax
	push	cx

	mov	ax,[TIACollide]
	mov	cx,si			; cx = address
	add	cl,cl			; shift it right 2 x address
	shr	ax,cl			; and do it....
	and	ax,3			; ax is now the 7,6 collide bits
	shl	al,6			; put them back in bits 7 and 6
	mov	[RetWd],al		; save word for returning

	pop	cx
	pop	ax
	mov	si,offset RetWd
	ret

ReadInputLatches:			; read the input latch
;	 call	 CheckPaddleLatches	; check the paddle latches
	add	si,offset DumpPorts-8
	ret
        

WBank4: and	si,01fffh
	cmp	si,1000h
	jb	WriteHardware
	ret
        
WBank8: and	si,01fffh
	cmp	si,1000h		; if not ROM,no effect
	jb	WriteHardware
	cmp	si,1FF8h		; if not in switch area...
	jb	Bank8NoChange		; theres no change
	cmp	si,1FFAh
	ja	Bank8NoChange
	mov	[RomBank],0		; selected bank 0
	cmp	si,1FF8h
	je	Bank8NoChange
	mov	[RomBank],1000h		; selected bank 1
Bank8NoChange:
	add	si,[RomBank]
WBRet:	ret
					        
WBank16:and	si,01fffh
	cmp	si,1000h		; if not ROM,no effect
	jb	WriteHardware
	cmp	si,1FF6h		; if not in switch area...
	jb	Bank16NoChange		; theres no change
	cmp	si,1FFAh
	ja	Bank16NoChange

	push	ax			; 16k ROM switch
	mov	ax,si
	sub	ax,1FF6h		; its 0,1,2,3
	shl	ax,12			; its 0,4k,8k,12k
	mov	[RomBank],ax
	pop	ax

Bank16NoChange:
	add	si,[RomBank]
	ret

; *****************************************************************************
;   Memory mapping - Write. On Entry , SI contains the address and [WByte]
;   the data. WSYNC and VSYNC are handled here as they affect the CPU timing
; *****************************************************************************

WriteHardware:
	cmp	si,0400h		; if > 400h don't write (ROM there)
	jge	WHret
	cmp	si,0200h		; writing to the RIOT ?
	jge	WriteRIOT
WriteHardwarePage0:
	and	si,0FFh
	cmp	si,080h			; writing to the TIA ?
	jl	WriteTIA
	add	si,offset RiotRam-128	; writing to the RAM
	mov	dl,[WByte]
	mov	[si],dl
WHret:	ret

WriteRIOT:
	and	si,02FFh		; can be at 2xx or 3xx
	cmp	si,0290h		; writing to the timer (0290-029F)
	jl	WHret			; go to the code that does that !
	jmp	SetTimer
        

WriteTIA:
	and	si,03Fh
	cmp	si,04h			; writing to a sync register
	jl	WrTiaImmediate		;   yes, handle immediately
	cmp	si,02ch			; check range
	jg	XTRet			;  all other TIA commands are written to a
	push	bx			; 'TIA change' buffer which records
	push	ax
	mov	al,[RClock]
	add	al,al
	add	al,[RClock]		; clock * 3
	sub	al,CycleOffset[si]	; - 68 or so (HBlank position)
	ja	XTIANotHBlank		; if < 0 its in HBlank area, ret 0
	xor	al,al			; (needed for nearly everything -- why?)
XTIANotHBlank:
	cmp	al,159			; must be < 160
	jb	XTIAOffRHS		; (needed for enduro -- but why?)
	mov	al,159
XTIAOffRHS:
	mov	bx,[TIAWritePointer]
	mov	TIAClock[bx],al
	mov	al,[WByte]	        
	mov	TIAVal[bx],al
	mov	ax,si
	mov	TIAReg[bx],al
	add	bx,4
	mov	[TIAWritePointer],bx
	mov	byte ptr TIAClock[bx],TIAEnd
	pop	ax
	pop	bx
XTRet:	ret


WrTiaImmediate:
	shl	si,1
	jmp	[WrTiaImmediateVector + SI]


; WSync -- wait for leading edge of horizontal blank

; this code is fixing up the timer by doing [TimerVec] calls for all
; the cycles left before VSYNC.
        
WrTiaWSync:
	call	[TimerVec]		; do timing for current instruction
	mov	bl,CyclesPerScanLine	; number of cycles left in the line
	sub	bl,byte ptr [RClock]	; number of clocks left to do.
	js	WSret			; if clock > 76 do nothing
WSyncLoop:
	cmp	bl,8			; max of 8 cycles at once.
	jl	WSyncExit		; if < 8 do the last few
	mov	[RCycles],8		; do 8 cycles
	push	bx
	call	[TimerVec]
	pop	bx
	sub	bl,8
	jmp	WSyncLoop

WSyncExit:
	mov	[RCycles],bl		; do the last few cycles in the
					; [Timervec] call following the return
	mov	[RClock],CyclesPerScanLine
WSret:	ret				; we're at the end of the line
					; fools the scan exec loop into finishing

; VSync -- vertical sync set-clear

WrTiaVSync:     
	test	[WByte],2		; if d1 is set then ....
	jz	WSret
	mov	[ScanLine],0		; back to screen top
;	mov	[RClock],0
	call	TIABlank
	inc	[Frame]			; new frame.
	Ret
        

; VBlank -- vertical blank set-clear

WrTiaVBlank:
	push	ax
	mov	bl,[WByte]
	mov	[VBlank],bl
	test	bl,2
	jz	WVBClear
	mov	[TopLine],65535		;turn off Tia
	jmp	WVBRet

WVBClear:
	mov	ax,[ScanLine]
	cmp	ax,[CFirst]
	jae	WVBPastMin
	mov	ax,[CFirst]
;	mov	ax,30			;good for Enduro
WVBPastMin:
	mov	[TopLine],ax
	add	ax,[MaxLines]
	mov	[BottomLine],ax

WVBRet:
	pop	ax
	ret      


;xWrTiaVBlank:
;	mov	bl,[WByte]
;	mov	[VBlank],bl
;	test	bl,2
;	jnz	WSret
       
;* now here's an interesting turn of events (vertical blank clear)

;	push	ax
;	mov	ax,[ScanLine]
;	cmp	ax,[CFirst]		; top line must be at least CFirst
;	jge	PastMin
;	mov	ax,[CFirst]
;	dec	ax
;PastMin:
;	inc	ax

;	mov	[TopLine],ax
;	add	ax,[MaxLines]		; 200 normally, should be 228 if shrunk
;	cmp	ax,[CLast]
;	jle	PastMax
;	mov	ax,[CLast]
;PastMax:
;	mov	[BottomLine],ax
;	pop	ax

;	ret

; cpu memory and register handlers -- used by the CPU emulator

;*
;* Process the timer...
;*

ALIGN_ENTRY

Timer1: movzx	dx,[RCycles]		; normal timer, decrements at 1 per
	sub	[Timer],dx		; processor cycle
Timer0:
	ret
					; this decs at various rates
ALIGN_ENTRY

Timer2: movzx	dx,[RCycles]		; subtract cycles from tickcount
	sub	[TickCnt],dx
	jl	DecTimer		; if its < 0,decrement the timer
	ret
DecTimer:
	mov	dx,[TRate]		; reset the tick counter
	add	[TickCnt],dx
	dec	[Timer]			; decrement the timer
	mov	dx,[Timer]
	cmp	dx,0FFFFh		; ticked round (on FFh bug fix)
	je	SetMode1		; if its zero count down in mode 1
	ret


;*
;* This is generated by writing to $0294 .. $0297, the RIOT timer regs
;* SI contains the address on entry. [WByte] is the timer value
;*

ALIGN_ENTRY

SetTimer:
	push	ax			; set the timer
	movzx	ax,[WByte]		; get the value to write
	mov	[Timer],ax		; and write it !
	pop	ax
	cmp	si,0294h		; is it the 1 clock timer
	je	SetMode1		; if so,go to mode 1

	push	ax			; it is the Mode n timer
	push	bx
	mov	bx,si			; work out the offset
	sub	bx,0295h
	add	bx,bx
	mov	ax,TimerCount[bx]	; get the counting value
	mov	[TRate],ax		; set the tick rate
	movzx	bx,[RCycles]
	add	ax,bx			; add the number of cycles for this inst
					; because after the write it'll be decd
	mov	[TickCnt],ax		; set the tick count
	mov	[TimerVec],offset Timer2; patch to call Timer2 routine
	pop	bx			; tidy up
	pop	ax
	ret

ALIGN_ENTRY

SetMode1:				; patch code to call the Timer1 routine
	mov	[TimerVec],offset Timer1
	ret


        
ALIGN_ENTRY

ReadHardware:
	cmp	si,0200h		; is it the RIOT ???
	jge	ReadRIOT
ReadHardwarePage0:
	and	si,0FFh			; it must be the TIA or RAM
	cmp	si,080h			; is it the TIA ???
	jl	ReadTIA
	add	si,offset RiotRam-128	; point si to the riotram area
	ret
					        
        
; *****************************************************************************
;     Memory Mapping - Read - For non-rom areas, SI contains the requested
;	address. On exit ds:[si] points to the actual required data
; *****************************************************************************

ALIGN_ENTRY

ReadRIOT:
	and	si,02FFh		; riot at 2xx 3xx
	cmp	si,0284h		; is it the RIOT timer ???
	jne	NotRTimer
	mov	si,offset Timer		; make SI point to the timer
	ret
NotRTimer:				; all the other RIOT Registers
	cmp	si,0280h		; is it Port A (Hand Controllers) ?
	je	ReadPortA
	cmp	si,0282h		; is it Port B (Console Switches) ?
	je	ReadPortB
	mov	si,offset RetFF
	ret
ReadPortB:				; read console switches (port b)
	mov	si,offset IOPortB
	ret
ReadPortA:				; read hand controllers (port b)
	mov	si,offset IOPortA
	ret

ALIGN_ENTRY

ReadTIA:and	si,0Fh
	cmp	si,08h			; reading collision registers ???
	jl	ReadCollision
	cmp	si,0Eh
	jl	ReadInputLatches
	mov	si,offset Ret0F		; read the TIA (default)
	ret
        

ALIGN_ENTRY

ReadCollision:				; read the collision latch
	push	ax
	push	cx

	mov	ax,[TIACollide]
	mov	cx,si			; cx = address
	add	cl,cl			; shift it right 2 x address
	shr	ax,cl			; and do it....
	and	ax,3			; ax is now the 7,6 collide bits
	shl	al,6			; put them back in bits 7 and 6
	mov	[RetWd],al		; save word for returning

	pop	cx
	pop	ax
	mov	si,offset RetWd
	ret

ALIGN_ENTRY

ReadInputLatches:			; read the input latch
;	 call	 CheckPaddleLatches	; check the paddle latches
	add	si,offset DumpPorts-8
	ret
        


; *****************************************************************************
;   Memory mapping - Write. On Entry , SI contains the address and [WByte]
;   the data. WSYNC and VSYNC are handled here as they affect the CPU timing
; *****************************************************************************

ALIGN_ENTRY

WriteHardware:
	cmp	si,0400h		; if > 400h don't write (ROM there)
	jge	WHret
	cmp	si,0200h		; writing to the RIOT ?
	jge	WriteRIOT
WriteHardwarePage0:
	and	si,0FFh
	cmp	si,080h			; writing to the TIA ?
	jl	WriteTIA
	mov	dl,[WByte]		; writing to RAM
	mov	[RiotRam-128 + si],dl
WHret:	ret

ALIGN_ENTRY

WriteRIOT:
	and	si,02FFh		; can be at 2xx or 3xx
	cmp	si,0290h		; writing to the timer (0290-029F)
	jl	WHret			; go to the code that does that !
	jmp	SetTimer
        

ALIGN_ENTRY

WriteTIA:
	and	si,03Fh
	cmp	si,04h			; writing to a sync register
	jl	WrTiaImmediate		;   yes, handle immediately
	cmp	si,02ch			; check range
	jg	XTRet			;  all other TIA commands are written to a

	push	bx			; 'TIA change' buffer which records
	push	ax
	mov	al,[RClock]
	add	al,al
	add	al,[RClock]		; clock * 3
	sub	al,CycleOffset[si]	; - 68 or so (HBlank position)
	ja	XTIANotHBlank		; if < 0 its in HBlank area, ret 0
	xor	al,al			; (needed for nearly everything -- why?)
XTIANotHBlank:
	cmp	al,159			; must be < 160
	jb	XTIAOffRHS		; (needed for enduro -- but why?)
	mov	al,159
XTIAOffRHS:
	call	FindInsert		; do insertion in clock order
	mov	bx,[TIAWritePointer]
	mov	TIAClock[bx],al
	mov	al,[WByte]	        
	mov	TIAVal[bx],al
	mov	ax,si
	mov	TIAReg[bx],al
	pop	ax
	pop	bx
XTRet:	ret


ALIGN_ENTRY

WrTiaImmediate:
	shl	si,1
	jmp	[WrTiaImmediateVector + SI]


; WSync -- wait for leading edge of horizontal blank

; this code is fixing up the timer by doing [TimerVec] calls for all
; the cycles left before VSYNC.
        
ALIGN_ENTRY

WrTiaWSync:
	call	[TimerVec]		; do timing for current instruction
	mov	bl,CyclesPerScanLine	; number of cycles left in the line
	sub	bl,byte ptr [RClock]	; number of clocks left to do.
	js	WSret			; (was js) if clock > 76 do nothing
WSyncLoop:
	cmp	bl,8			; max of 8 cycles at once.
	jl	WSyncExit		; if < 8 do the last few
	mov	[RCycles],8		; do 8 cycles
	push	bx
	call	[TimerVec]
	pop	bx
	sub	bl,8
	jmp	WSyncLoop

WSyncExit:
	mov	[RCycles],bl		; do the last few cycles in the
					; [Timervec] call following the return
	mov	[RClock],CyclesPerScanLine
WSret:	ret				; we're at the end of the line
					; fools the scan exec loop into finishing

; VSync -- vertical sync set-clear

;* this stuff looks wrong
;* it's the zero state of vsync that should set scanline to zero

ALIGN_ENTRY

WrTiaVSync:
	push	ax			; lasrgate needs this
	test	[ReverseSync],1
	jnz	DoReverseTest

	test	[WByte],2		; if d1 is set then ....
	jnz	ZRET			; was jz
	jmp	DoVSync

DoReverseTest:
	test	[WByte],2		; if d1 is set then ....
	jz	ZRET

DoVSync:
	mov	[ScanLine],0		; back to screen top
	inc	[Frame]			; new frame.
	mov	ax,[CFirst]
	cmp	ax,0			; forcing first line ?
	jz	ZRET			;   no, let vblank take care of it
	mov	[TopLine],ax
ZRET:	pop	ax
	Ret


; VBlank -- vertical blank set-clear

ALIGN_ENTRY

WrTiaVBlank:
	push	ax
	mov	bl,[WByte]
	mov	[VBlank],bl
	test	bl,2			; setting or clearing ?
	jz	WVBClear		;   clearing
	mov	[TopLine],65535		;   setting -- turn off Tia
	call	TIABlank		; clear rest of screen
	jmp	WVBRet

WVBClear:
	mov	ax,[ScanLine]
	cmp	ax,[CFirst]
	jae	WVBPastMin
	mov	ax,[CFirst]
WVBPastMin:
	inc	ax
	mov	[TopLine],ax
	add	ax,MaxLines		; was MaxLines [_VideoHeight]
	mov	[BottomLine],ax
	cmp	[VBlankFrame],0
	jz	WVBRet
	inc	[Frame]			; for bowling !
WVBRet:
	pop	ax
	ret      

;*
;* blank the remainder of the display each frame
;*

ALIGN_ENTRY

TIABlank:
	push	ax
	push	di
	xor	ax,ax
	mov	di,[DisplayPointer]
	cmp	di,30000
	jb	TIABRet
TIABLoop:
	cmp	di,65280		; (64000) reached end of display area?
	jae	TIABRet			;    yes, done
	mov	gs:[di],ax
	add	di,2
	jmp	TIABLoop

TIABRet:
	mov	[DisplayPointer],di
	pop	di
	pop	ax
	ret


;xWrTiaVBlank:
;	mov	bl,[WByte]
;	mov	[VBlank],bl
;	test	bl,2
;	jnz	WSret
       
;* now here's an interesting turn of events (vertical blank clear)

;	push	ax
;	mov	ax,[ScanLine]
;	cmp	ax,[CFirst]		; top line must be at least CFirst
;	jge	PastMin
;	mov	ax,[CFirst]
;	dec	ax
;PastMin:
;	inc	ax

;	mov	[TopLine],ax
;	add	ax,[MaxLines]		; 200 normally, should be 228 if shrunk
;	cmp	ax,[CLast]
;	jle	PastMax
;	mov	ax,[CLast]
;PastMax:
;	mov	[BottomLine],ax
;	pop	ax

;	ret

; *****************************************************************************
;			   MAIN CODE STARTS HERE
; *****************************************************************************

start:

IFNDEF comfile
	mov	ax,_TEXT
	mov	ds,ax			;set up data segment
	mov	bx,es
	mov	psp,bx			;save pointer to PSP
	mov	es,ax			;set up extra segment
	cli
	mov	ss,ax			;set up stack segment
	mov	sp,offset mystack	;  and stack pointer
	sti
ENDIF   
        
	mov	[CartRom+0FFCh],0	; set the default reset address
	mov	[CartRom+0FFDh],0f0h	; to F000

	call	CommandLine		; Process the command line
	call	Reset			; Reset the CPU
	call	RSave			; save the CPU status
	call	TIAGraphicMode		; Switch into VGA mode
	call	SetNewInt9		; Keyboard Handler


;*
;* the main outer loop
;*

xmain:  
;	BLIP_HP_HALF
;	TIMER_OFF
        
	mov	dx,03dah		; wait for vertical retrace
WaitForVR:
	in	al,dx
	test	al,8
	jnz	VRDone
	jmp	WaitForVR

VRDone:
;	 TIMER_ON

	call	ScanFrame		;* flat out!!
	call	[CtrlFn]		;*
	jmp	xmain			;*


;*
;* end of program (escape pressed or bad opcode)
;*

GoDOS:
	call	SoundOff		; turn sound off
	call	TIATextMode		; back to text mode
	call	SetOldInt9		; reset the key handler

					; empty the keyboard buffer
Empty:	mov	ah,0Bh			; key waiting....
	int	MSDOS
	cmp	al,0FFh			; if not,exit
	jne	Quit
	call	ConIn			; read it
	jmp	Empty
Quit:	
	mov	dx,offset CopyRight
	mov	ah,9
	int	MSDOS			; output the copyright msg
	mov	ah,04Ch			; and return to MSDOS
	int	MSDOS



;*
;* Do One Frame
;*

ScanFrame:
	mov	ax,0a000h
	mov	gs,ax			; point GS to VGA area
        mov	[DisplayPointer],0	; reset display pointer
ScanFrameLoop:
	mov	bx,[ScanLine]		; reset the TIA for a new line
	mov	[TIAScanLine],bx
	mov	bx,offset TIABuffer
	mov	[TIAWritePointer],bx
	mov	dword ptr [bx],-1	;* look ma, it's a dword pointer *
	xor	dl,dl			; next clock line for playfield write..
	call	RLoad			; load the CPU registers

;*
;* do some instructions
;*

InstructionLoop:
	fetch	bl			; get the opcode
	xor	bh,bh
	mov	dl,Cycles[bx]		; get cycles takes to do it
	mov	[RCycles],dl		; save the number of cycles
	add	[RClock],dl		; add to the clock
	shl	bx,1
	jmp	[vectors + bx]		; --> do the instruction

ualnext:usetest al			; <-- instruction done
next:	call	[TimerVec]		; <-- instruction done, clock the RIOT timer
	cmp	[RClock],CyclesPerScanLine-2	;* why -2?
	jl	InstructionLoop

;*
;* we've done a line full of instructions
;*

	call	RSave			; save the CPU registers

	pusha
	call	TIALineTo		; generate a raster line
	popa

	inc	[ScanLine]		; Increment the scanline counter
	sub	[RClock],CyclesPerScanLine

; * this stuff is only needed if a game doesn't write to vsync
; * like bowling

	mov	ax,[ScanLine]		; (chopper command needs 266)
	cmp	ax,270			; have we done all 262 scan lines yet?
	jl	NDret			;   not yet
	inc	[Frame]			;   yes, to the next frame
	mov	[ScanLine],0
;	call	TIABlank

NDret:  
	mov	ax,[Frame]
	cmp	ax,[PrevFrame]		; have we gone to a new frame ?
	je	ScanFrameLoop		;   not yet
	mov	[PrevFrame],ax		;   yes, mark it as current
	ret				;	 and return

;*
;* blank the remainder of the display each frame
;*

TIABlank:
	push	ax
	push	di
	xor	ax,ax
	mov	di,[DisplayPointer]
TIABLoop:
	cmp	di,30000
	jb	TIABRet
	cmp	di,64000		; reached end of display area?
	jae	TIABRet			;    yes, done
	mov	gs:[di],ax
	add	di,2
	jmp	TIABLoop

TIABRet:
	mov	[DisplayPointer],di
	pop	di
	pop	ax
	ret

;*
;* come here when duff opcode 
;*
;* (Q: Whatsa duff opcode?  A: I dunno.	 Q: zen )
;*

fail:	dec	bp			; backup the instruction pointer
	read	al,bp			; read the byte
	call	ConHex			; display it
	mov	al,'@'			; here comes the address
	call	ConOut
	mov	ax,bp			; pick up the address
	call	ConWord			; display it
WaitEsc:test	[KeyTable+KeyEsc],128	; wait for ESC to be pressed
	jz	WaitEsc
	jmp	GoDOS


;*
;* Process the timer...
;*

Timer1: movzx	dx,[RCycles]		; normal timer, decrements at 1 per
	sub	[Timer],dx		; processor cycle
Timer0:
	ret
					; this decs at various rates
Timer2: movzx	dx,[RCycles]		; subtract cycles from tickcount
	sub	[TickCnt],dx
	jl	DecTimer		; if its < 0,decrement the timer
	ret
DecTimer:
	mov	dx,[TRate]		; reset the tick counter
	add	[TickCnt],dx
	dec	[Timer]			; decrement the timer
	mov	dx,[Timer]
	cmp	dx,0FFFFh		; ticked round (on FFh bug fix)
	je	SetMode1		; if its zero count down in mode 1
	ret

;*
;* This is generated by writing to $0294 .. $0297, the RIOT timer regs
;* SI contains the address on entry. [WByte] is the timer value
;*

SetTimer:
	push	ax			; set the timer
	movzx	ax,[WByte]		; get the value to write
	mov	[Timer],ax		; and write it !
	pop	ax
	cmp	si,0294h		; is it the 1 clock timer
	je	SetMode1		; if so,go to mode 1

	push	ax			; it is the Mode n timer
	push	bx
	mov	bx,si			; work out the offset
	sub	bx,0295h
	add	bx,bx
	mov	ax,TimerCount[bx]	; get the counting value
	mov	[TRate],ax		; set the tick rate
	movzx	bx,[RCycles]
	add	ax,bx			; add the number of cycles for this inst
					; because after the write it'll be decd
	mov	[TickCnt],ax		; set the tick count
	mov	[TimerVec],offset Timer2; patch to call Timer2 routine
	pop	bx			; tidy up
	pop	ax
	ret

SetMode1:				; patch code to call the Timer1 routine
	mov	[TimerVec],offset Timer1
	ret


;*
;* Read bank switcher (SI contains the address accessed)
;*

RBank4: and	si,01fffh
	cmp	si,1000h		; if not ROM, read hardware
	jb	ReadHardware
	add	si,offset CartRom - 1000h
	ret
        
RBank8: and	si,01fffh
	cmp	si,1000h		; if not ROM, read hardware
	jb	ReadHardware
	cmp	si,1FF8h		; if not in switch area...
	jb	RBank8NoChange		; theres no change
	cmp	si,1FFAh
	ja	RBank8NoChange
	mov	[RomBank],0		; selected bank 0
	cmp	si,1FF8h
	je	RBank8NoChange
	mov	[RomBank],1000h		; selected bank 1
RBank8NoChange:
	add	si,[RomBank]
	add	si,offset CartRom - 1000h
	ret
        
ReadHardware:
	cmp	si,0200h		; is it the RIOT ???
	jge	ReadRIOT
ReadHardwarePage0:
	and	si,0FFh			; it must be the TIA or RAM
	cmp	si,080h			; is it the TIA ???
	jl	ReadTIA
	add	si,offset RiotRam-128	; point si to the riotram area
	ret
					        
RBank16: and	si,01fffh
	cmp	si,1000h		; if not ROM, read hardware
	jb	ReadHardware
	cmp	si,1FF6h		; if not in switch area...
	jb	RBank16NoChange		; theres no change
	cmp	si,1FFAh
	ja	RBank16NoChange

	push	ax			; 16k ROM switch
	mov	ax,si
	sub	ax,1FF6h		; its 0,1,2,3
	shl	ax,12			; its 0,4k,8k,12k
	mov	[RomBank],ax
	pop	ax

RBank16NoChange:
	add	si,[RomBank]
	add	si,offset CartRom - 1000h
	ret
        
; *****************************************************************************
;     Memory Mapping - Read - For non-rom areas, SI contains the requested
;	address. On exit ds:[si] points to the actual required data
; *****************************************************************************

ReadRIOT:
	and	si,02FFh		; riot at 2xx 3xx
	cmp	si,0284h		; is it the RIOT timer ???
	jne	NotRTimer
	mov	si,offset Timer		; make SI point to the timer
	ret
NotRTimer:				; all the other RIOT Registers
	cmp	si,0280h		; is it Port A (Hand Controllers) ?
	je	ReadPortA
	cmp	si,0282h		; is it Port B (Console Switches) ?
	je	ReadPortB
	mov	si,offset RetFF
	ret
ReadPortB:				; read console switches (port b)
	mov	si,offset IOPortB
	ret
ReadPortA:				; read hand controllers (port b)
	mov	si,offset IOPortA
	ret

ReadTIA:and	si,0Fh
	cmp	si,08h			; reading collision registers ???
	jl	ReadCollision
	cmp	si,0Eh
	jl	ReadInputLatches
	mov	si,offset Ret0F		; read the TIA (default)
	ret
        

ReadCollision:				; read the collision latch
	push	ax
	push	cx

	mov	ax,[TIACollide]
	mov	cx,si			; cx = address
	add	cl,cl			; shift it right 2 x address
	shr	ax,cl			; and do it....
	and	ax,3			; ax is now the 7,6 collide bits
	shl	al,6			; put them back in bits 7 and 6
	mov	[RetWd],al		; save word for returning

	pop	cx
	pop	ax
	mov	si,offset RetWd
	ret

ReadInputLatches:			; read the input latch
;	 call	 CheckPaddleLatches	; check the paddle latches
	add	si,offset DumpPorts-8
	ret
        

WBank4: and	si,01fffh
	cmp	si,1000h
	jb	WriteHardware
	ret
        
WBank8: and	si,01fffh
	cmp	si,1000h		; if not ROM,no effect
	jb	WriteHardware
	cmp	si,1FF8h		; if not in switch area...
	jb	Bank8NoChange		; theres no change
	cmp	si,1FFAh
	ja	Bank8NoChange
	mov	[RomBank],0		; selected bank 0
	cmp	si,1FF8h
	je	Bank8NoChange
	mov	[RomBank],1000h		; selected bank 1
Bank8NoChange:
	add	si,[RomBank]
WBRet:	ret
					        
WBank16:and	si,01fffh
	cmp	si,1000h		; if not ROM,no effect
	jb	WriteHardware
	cmp	si,1FF6h		; if not in switch area...
	jb	Bank16NoChange		; theres no change
	cmp	si,1FFAh
	ja	Bank16NoChange

	push	ax			; 16k ROM switch
	mov	ax,si
	sub	ax,1FF6h		; its 0,1,2,3
	shl	ax,12			; its 0,4k,8k,12k
	mov	[RomBank],ax
	pop	ax

Bank16NoChange:
	add	si,[RomBank]
	ret

; *****************************************************************************
;   Memory mapping - Write. On Entry , SI contains the address and [WByte]
;   the data. WSYNC and VSYNC are handled here as they affect the CPU timing
; *****************************************************************************

WriteHardware:
	cmp	si,0400h		; if > 400h don't write (ROM there)
	jge	WHret
	cmp	si,0200h		; writing to the RIOT ?
	jge	WriteRIOT
WriteHardwarePage0:
	and	si,0FFh
	cmp	si,080h			; writing to the TIA ?
	jl	WriteTIA
	add	si,offset RiotRam-128	; writing to the RAM
	mov	dl,[WByte]
	mov	[si],dl
WHret:	ret

WriteRIOT:
	and	si,02FFh		; can be at 2xx or 3xx
	cmp	si,0290h		; writing to the timer (0290-029F)
	jl	WHret			; go to the code that does that !
	jmp	SetTimer
        

WriteTIA:
	and	si,03Fh
	cmp	si,04h			; writing to a sync register
	jl	WrTiaImmediate		;   yes, handle immediately
	cmp	si,02ch			; check range
	jg	XTRet			;  all other TIA commands are written to a
	push	bx			; 'TIA change' buffer which records
	push	ax
	mov	al,[RClock]
	add	al,al
	add	al,[RClock]		; clock * 3
	sub	al,CycleOffset[si]	; - 68 or so (HBlank position)
	ja	XTIANotHBlank		; if < 0 its in HBlank area, ret 0
	xor	al,al			; (needed for nearly everything -- why?)
XTIANotHBlank:
	cmp	al,159			; must be < 160
	jb	XTIAOffRHS		; (needed for enduro -- but why?)
	mov	al,159
XTIAOffRHS:
	mov	bx,[TIAWritePointer]
	mov	TIAClock[bx],al
	mov	al,[WByte]	        
	mov	TIAVal[bx],al
	mov	ax,si
	mov	TIAReg[bx],al
	add	bx,4
	mov	[TIAWritePointer],bx
	mov	byte ptr TIAClock[bx],TIAEnd
	pop	ax
	pop	bx
XTRet:	ret


WrTiaImmediate:
	shl	si,1
	jmp	[WrTiaImmediateVector + SI]


; WSync -- wait for leading edge of horizontal blank

; this code is fixing up the timer by doing [TimerVec] calls for all
; the cycles left before VSYNC.
        
WrTiaWSync:
	call	[TimerVec]		; do timing for current instruction
	mov	bl,CyclesPerScanLine	; number of cycles left in the line
	sub	bl,byte ptr [RClock]	; number of clocks left to do.
	js	WSret			; if clock > 76 do nothing
WSyncLoop:
	cmp	bl,8			; max of 8 cycles at once.
	jl	WSyncExit		; if < 8 do the last few
	mov	[RCycles],8		; do 8 cycles
	push	bx
	call	[TimerVec]
	pop	bx
	sub	bl,8
	jmp	WSyncLoop

WSyncExit:
	mov	[RCycles],bl		; do the last few cycles in the
					; [Timervec] call following the return
	mov	[RClock],CyclesPerScanLine
WSret:	ret				; we're at the end of the line
					; fools the scan exec loop into finishing

; VSync -- vertical sync set-clear

WrTiaVSync:     
	test	[WByte],2		; if d1 is set then ....
	jz	WSret
	mov	[ScanLine],0		; back to screen top
;	mov	[RClock],0
	call	TIABlank
	inc	[Frame]			; new frame.
	Ret
        

; VBlank -- vertical blank set-clear

WrTiaVBlank:
	push	ax
	mov	bl,[WByte]
	mov	[VBlank],bl
	test	bl,2
	jz	WVBClear
	mov	[TopLine],65535		;turn off Tia
	jmp	WVBRet

WVBClear:
	mov	ax,[ScanLine]
	cmp	ax,[CFirst]
	jae	WVBPastMin
	mov	ax,[CFirst]
;	mov	ax,30			;good for Enduro
WVBPastMin:
	mov	[TopLine],ax
	add	ax,[MaxLines]
	mov	[BottomLine],ax

WVBRet:
	pop	ax
	ret      


;xWrTiaVBlank:
;	mov	bl,[WByte]
;	mov	[VBlank],bl
;	test	bl,2
;	jnz	WSret
       
;* now here's an interesting turn of events (vertical blank clear)

;	push	ax
;	mov	ax,[ScanLine]
;	cmp	ax,[CFirst]		; top line must be at least CFirst
;	jge	PastMin
;	mov	ax,[CFirst]
;	dec	ax
;PastMin:
;	inc	ax

;	mov	[TopLine],ax
;	add	ax,[MaxLines]		; 200 normally, should be 228 if shrunk
;	cmp	ax,[CLast]
;	jle	PastMax
;	mov	ax,[CLast]
;PastMax:
;	mov	[BottomLine],ax
;	pop	ax

;	ret
        


; *****************************************************************************
;
;			       TIA Emulator
;
;	Don't worry about - colours changing in mid playfield (yet)
;
; *****************************************************************************

; *****************************************************************************
;
;	Continue line building at last until column dh is reached
;	from where we previously left off (if registers still ok)
;
;	BP points to the start of the TIA Buffer
;	DL next playfield write position
;	DH limit of line building
;	SI next playfield write address
;
;	This code works down the TIABuffer which is a list of events
;	mostly writing to the TIA events, but there are special events
;	to handle putting the previous line graphic down (basically simulates
;	doing RESxxx in the same place) and multiple graphic copies (by doing
;	a dummy RESxxx that doesn't recent the horizontal position register).
;
;	Mixed in with this is test for the playfield draw,which is done in
;	4 bit 'chunks'. At the beginning of the loop, we see if the next
;	playfield write is due before the next line output. If it is, we
;	do it. If not , the next playfield write is done and so on until
;	the screen line is built.
;
;	The screen line is an array, with 6 bits, each representing the
;	presence of a screen object (pf,bl,m0,p0,m1,p1)
;
;	On entry, you must set the 'draw to' (DH). It then draws from
;	the start position to DH.
;
; *****************************************************************************

;*
;* collision test macros
;*

CollisionTest macro op1
	mov	bl,op1[si]
	cmp	bl,3
	jb	TIACollisionNext&op1
	shl	bl,1    
	jc	TIACollisionClear&op1	;   if collision reset bit set
	or	di,TIAColTab[bx]
	jmp	TIACollisionNext&op1
        
TIACollisionClear&op1:
	xor	di,di
	or	di,TIAColTab[bx]
TIACollisionNext&op1:

	endm

Collision4 macro
	mov	di,[TIACollide]		; do the collision test
	xor	bh,bh
        
	CollisionTest 0
	CollisionTest 1
	CollisionTest 2
	CollisionTest 3

	mov	[TIACollide],di

	endm

;*
;* output conversion macros
;*

ConvertOut macro op1
	mov	bl,op1[si]		;pick up a byte from TIADisplay
	and	bx,03fh			;mask off collision reset bits
	mov	di,[DisplayTranslate]
	mov	bl,[di+bx]
	mov	bl,TIAColourTable[bx]	;pointer to color register
	mov	al,TIA[bx]		;color value
	shr	al,1
	mov	ah,al			;two bytes at a time
	mov	di,[DisplayPointer]	
	mov	gs:[di],ax
	add	di,2
	mov	[DisplayPointer],di
	endm

Convert4 macro
local	L1

	mov	ax,offset TIADisplayToColour
	test	[TIA+TIACtrlPf],4	;if pf has priority, use alternate translation
	jz	L1
	mov	ax,offset TIADisplayToColour2
L1:
	mov	[DisplayTranslate],ax
	ConvertOut 0
	ConvertOut 1
	ConvertOut 2
	ConvertOut 3
	endm

;*
;* macro to output a playfield bit
;*
;* there may be a bug in here
;*   try seaquest 
;*   there's a stripe in the middle when playfield takes on player color wrongly
;* 

PlayfieldBit macro
local PFDoIt, PFSkip, L1, L2
	mov	[TIAColourTable+TCTPF],TIAColupf
	test	[TIA+TIACtrlPf],2	; if colour split, pf col = p0 col
	jz	L2
	mov	[TIAColourTable+TCTPF],TIAColup0
L2:    	cmp	dl,80			; do a playfield bit, at center of screen ?
	jne	PFDoIt			;   no, just do it

	test	[TIA+TIACtrlPf],2	;   yes, if colour split, pf col = p1 col
	jz	L1
	mov	[TIAColourTable+TCTPF],TIAColup1
L1:	test	[TIA+TIACtrlPf],1	; reversing the current line ?
	jnz	PFDoIt			;    yes, continue
	xor	cx,cx			;    no, restart from beginning

PFDoIt:					; note: one pf bit = 4 color clocks
	mov	bx,cx
	mov	eax,dword ptr [TIA+TIAPf0]
	test	eax,PfClockToBitTable[bx]
	jz	PFSkip
	or	dword ptr [si],TGPlay*01000000h+TGPlay*010000h+TGPlay*0100h+TGPlay
PFSkip:
	endm

;*
;* macro to process objects
;*

DoObjects macro
local TIAObjectLoop, TIASkip, TIAObjectDone

TIAObjectLoop:
	cmp	TIAClock[bp],dl		
	ja	TIAObjectDone		; if next change clock <= next pf write
	mov	bl,TIAReg[bp]		;   go to the register change handler
	and	bx,03fh			; only 63 options !!
	shl	bx,1
	call	TIARegVector[bx]
        
TIASkip:add	bp,4			; go on to the next change
	cmp	byte ptr TIAClock[bp],TIAInvalid ; if moved onto an invalid
	je	TIASkip			; skip it.
	jmp	TIAObjectLoop
        
TIAObjectDone:

	endm	

; *     
; *  TIALineTo -- generate a raster line        
; *
; *  This is the main inner loop -- everything is time critical
; *

TIALineTo:
	mov	bp,offset TIABuffer	; initialise the buffer

	mov	bx,[ScanLine]
	cmp	bx,[TopLine]		;was 10
	jb	TIANoGenerate
	cmp	bx,[BottomLine]		;was 250
	jae	TIANoGenerate

TIAGenerate:
	mov	si,offset TIADisplay	; playfield write pointer

	mov	di,si
	xor	eax,eax
	mov	cx,40
	rep	stosd			; clear the TIA display buffer

	call	TIAInsertObjects	; insert objects from the last line

	xor	dl,dl			; start position
	xor	cx,cx			; clear playfield clock

TIALoop:
	DoObjects
	PlayfieldBit
	add	dl,4			; increment color clock
	add	cx,4			; increment playfield clock
	
	DoObjects
	Convert4
	Collision4

	add	si,4			; increment pf write / collision pointer
	cmp	dl,160			; reached end of line?
	jae	TIAExit			;   yes, exit
	jmp	TIALoop

TIAExit:				; we've finished the line scan...
	ret

;*
;* do a blank line (outside of display area)
;*

TIANoGenerate:
TIABLLoop:
	cmp	byte ptr TIAClock[bp],TIAEnd	; check if finished
	je	TIABLExit
	mov	bl,TIAReg[bp]		; register to change
	and	bx,03fh			; only 63 options !
	shl	bx,1
	call	TIARegVector2[bx]
	add	bp,4
	jmp	TIABLLoop
TIABLExit:
	ret


;*
;* register handlers
;*

TRSond: mov	bl,TIAReg[bp]		; bl = register
	mov	bh,TIAVal[bp]		; bh = data
	call	Sound			; do some sound stuff
	ret

TRCClr: mov	bl,TIAClock[bp]		; clear the collision flag
					; bh is already zero
	or	byte ptr TIADisplay[bx],80h ; set the bit 7 in the display field
	ret
	        
TRNoop: ret				; just ignore it ......

TRCopy: mov	bl,TIAReg[bp]		; register copy.offset in bx
					; bh is already zero
	mov	al,TIAVal[bp]		; value in al
	mov	TIA[bx],al		; write it
	ret

TRHClr: xor	al,al			; clear the HMove registers
	mov	[TIA+TIAHmp0],al
	mov	[TIA+TIAHmp1],al
	mov	[TIA+TIAHmm0],al
	mov	[TIA+TIAHmm1],al
	mov	[TIA+TIAHmbl],al
	ret

TRGrp0: mov	al,TIAVal[bp]		; update graphics register 0
	mov	[TIA+TIAGrp0],al
	mov	al,[TIA+TIAGrp1]	; copy Grp1 to Grp1 VDelay
	mov	[VDP1Gr],al
	ret

TRGrp1: mov	al,TIAVal[bp]		; update graphics register 1
	mov	[TIA+TIAGrp1],al
	mov	al,[TIA+TIAGrp0]	; update the vertical delay registers
	mov	[VDP0Gr],al		; for GRP 0 and ENABL
	mov	al,[TIA+TIAEnabl]
	mov	[VDBlEn],al
	ret

; *****************************************************************************
;
;	Handle HMOVE. Adjust old locations (those already written)
;	by the amount in the HMxxx registers
;
; *****************************************************************************

TRHMov: xor	bx,bx			; bx is offset into registers
TRHMLoop:
	mov	al,bl			; get the register to find...
	add	al,090h			; you move the OLD COPY
	mov	ah,TIA+TIAHmp0[bx]	; this is the amount to move
	sar	ah,4			; preserve sign 
	call	TIAUpdatePosition	; update the position
	inc	bx			; there are 5 to do.
	cmp	bx,5
	jne	TRHMLoop
	call	TIASortBuffer		; order may have been compromised
	ret


; * now here's some code I don't understand *

TIAWrap macro
local TWneg,TWret

	cmp	al,240			; went negative ???
	ja	TWneg			;   yes, adjust
	cmp	al,160			; past right side ?
	jb	TWret			;   no
	sub	al,160			;   yes
	jmp	TWret

TWneg:	add	al,160			; adjust
TWret:
	endm


TIAUpdatePosition:
	push	ax
	push	bp
	mov	bp,offset TIABuffer
TIAUP2: 
	cmp	byte ptr TIAClock[bp],TIAEnd	; check at the end
	je	TIAUP1
	add	bp,4
	cmp	TIAReg-4[bp],al		; check if found the added one
	jne	TIAUP2
	sub	bp,4			; bp points to it
	mov	al,TIAClock[bp]
	sub	al,ah			; add the offset to it
	TIAWrap
	mov	TIAClock[bp],al
TIAUP1: pop	bp
	pop	ax
	ret

					; Routine. Set register = clock value
TRSave: mov	bl,TIAReg[bp]		; bx = offset to register
					; bh is already zero
	mov	al,TIAClock[bp]		; ax = clock
	mov	TIA[bx],al
	ret
        

TRCxZr: mov	[TIACollide],0		; reset the collision word
	ret

TRHmvB: mov	bx,0
TRHMB1: mov	ah,TIA+TIAHmp0[bx]	; get the adjustment
	sar	ah,4			; preserve sign
	mov	al,TIA+TIAResp0[bx]
	sub	al,ah			; adjust it !
	TIAWrap
	mov	TIA+TIAResp0[bx],al
	inc	bx
	cmp	bx,5
	jne	TRHMB1
	ret

; *****************************************************************************
;
;			   Ball handling code
;
; *****************************************************************************

TRBall:					; ok , we've found a ball draw.....
	mov	bl,[TIA+TIAVDelbl]	; look at vertical ball delayed
	mov	al,[TIA+TIAEnabl]	; is the ball enabled flag (normal)
	test	bl,1
	jz	TRBBall2
	mov	al,[VDBlEn]		; is the ball enabled flag (delayed)
TRBBall2:
	test	al,2			; test if the ball is enabled....
	jz	TRBNoDraw

	mov	bl,TIAClock[bp]		; get the clock value
	xor	bh,bh			; bx offset to clock
	add	bx,offset TIADisplay	; bx points to ball start in line
	mov	al,[TIA+TIACtrlPf]	; al (b5,b4) are the size
	mov	ah,TGBall		; ah is the ball bit
	call	TIASolidObject

TRBNoDraw:
	mov	al,TIAClock[bp]		; update RESBl counter with clock
	mov	[TIA+TIAResbl],al	; so its drawn on the next line
	mov	al,TIAReg[bp]		; register that was written....
	test	al,128			; if bit 7 is clear (new Res...)
	jnz	TNret
	or	al,128
	call	TIAInvalidate		; invalidate old copies
TNret:	ret

; *****************************************************************************
;
;		       Missile handling code
;
;	On entry	BP Points to the missile record (clock/addr/data/0)
;
; *****************************************************************************

TRMiss:					; ok , we've found a missile draw....
	mov	bl,TIAReg[bp]		; bx = 0 if m0,bx = 1 if m1
	and	bx,1

	mov	al,TIA+TIAResmp0[bx]	; if its locked to the player
	test	al,2			; don't do anything at all !
	jnz	TNret

	mov	al,TIA+TIAEnam0[bx]	; get the enable flag
	test	al,2			; if zero,don't draw
	jz	TRMNoDraw

	mov	al,TIA+TIANuSiz0[bx]	; get the missile size
	mov	ah,TGMissile0		; and the pixel to set
	cmp	bl,0			; which is different for the missiles !
	jz	TGMCDraw
	mov	ah,TGMissile1
TGMCDraw:
	push	bx
	mov	bl,TIAClock[bp]		; get clock value (bh already 0)
	add	bx,offset TIADisplay	; bx points to ball start in line
	call	TIASolidObject		; draw the object .....
	pop	bx
TRMNoDraw:
	mov	al,TIAClock[bp]		; update RESm# counter with clock
	mov	TIA+TIAResm0[bx],al	; so its drawn on the next line
	mov	al,TIAReg[bp]		; register that was written....
	test	al,128			; if bit 7 is clear (new Res...)
	jnz	TGret
	or	al,128
	call	TIAInvalidate		; invalidate old copies
TGret:	ret

; *****************************************************************************
;
;	look for the first item in TIABuffer (BP) where Register = al
;	and mark it invalid
;
; *****************************************************************************

TIAInvalidate:
	push	bp
TIAI1:	mov	ah,TIAClock[bp]		; check if finished
	cmp	ah,TIAEnd
	je	TIAI2
	cmp	al,TIAReg[bp]		; if found, mark it
	je	TIAIMark
	add	bp,4			; do next until end
	jmp	TIAI1
TIAIMark:				; mark it invalid.
	mov	byte ptr TIAClock[bp],TIAInvalid
TIAI2:
	pop	bp
	ret

; *****************************************************************************
;
;    Draw solid object 1,2,4,8 clocks wide at address BX (ptr into display)
;    bit to set in AH, Size register in AL
;
; *****************************************************************************

TIASolidObject:
	and	al,030h			; mask out bits other than size
	jnz	TIASONot1
	or	[bx],ah			; set the bit
	ret
TIASONot1:
	push	cx
	mov	cl,ah			; cx = word version
	mov	ch,ah
	or	[bx],cx			; 2 clocks
	cmp	al,010h
	je	TSRet
	or	2[bx],cx		; 4 clocks
	cmp	al,020h
	je	TSRet
	or	4[bx],cx		; 8 clocks
	or	6[bx],cx
TSRet:  
	pop	cx
	ret
        

; *****************************************************************************
;
;				  Draw Player
;
;	On entry	BP Points to the missile record (clock/addr/data/0)
;
; *****************************************************************************


TRPlyr: 
	push	cx			; ok , we've found a player draw....
	mov	bl,TIAReg[bp]		; bx = 0 if p0, bx = 1 if p1
	and	bx,1

	mov	ah,TGPlayer0		; and the pixel to set
	cmp	bl,0			; which is different for the players !
	jz	TGPCDraw
	mov	ah,TGPlayer1
TGPCDraw:
	mov	al,TIA+TIANuSiz0[bx]	; size in al
	mov	cl,TIAReg[bp]		; if its a +64 write always size 0
	test	cl,64			; (we're doing a copied player from below)
	jz	TGPCNoCopy
	xor	al,al
TGPCNoCopy:
	mov	ch,TIA+TIAGrp0[bx]	; graphic in ch
	mov	cl,TIA+TIAVDelp0[bx]	; if vertical delay set
	test	cl,1
	jz	TGPCNoVDelay
	mov	ch,VDP0Gr[bx]		; use the vertical delay graphic
TGPCNoVDelay:
	mov	cl,TIA+TIARefP0[bx]	; reflection in cl
	push	bx
	mov	bl,TIAClock[bp]		; get clock value (bh already 0)
	add	bx,offset TIADisplay	; bx points to player start in line

	push	si
	call	TIAGraphObject		; call the graph object routine
	pop	si
	pop	bx

	mov	al,TIAReg[bp]		; if its a copy draw....
	test	al,64			; (e.g. bit 6 is set)
	jnz	TRPNoSetRes		; don't set RESP# from the clock

	mov	al,TIAClock[bp]		; update RESp# counter with clock
	mov	TIA+TIAResp0[bx],al	; so its drawn on the next line

; *** HMMMM... ***

	mov	ah,TIA+TIAResmp0[bx]	; if missile attached to player
	test	ah,2
	jz	TRPNoSetRes
	add	al,4			; missile at centre of player.
	mov	TIA+TIAResm0[bx],al

TRPNoSetRes:
	mov	al,TIAReg[bp]		; register that was written....
	test	al,128			; if bit 7 is clear (new Res...)
	jnz	TRPret
	or	al,128
	call	TIAInvalidate		; invalidate old copies
TRPret:
	pop	cx
	ret

; *****************************************************************************
;
;	 Draw player graphic CH in size/copy AL at screen at BX.
;	 CL = Reflection Flag,AH is bit to set
;
; *****************************************************************************


TIAGraphObject:
	and	al,7			; only required bits from Graphic
	jnz	TGODifferent		;   if anything weird...
TGOStd: 
	cmp	ch,0			; do standard
	jz	TGORet			;   if zero, do nothing
	test	cl,8			; reflected ?
	jnz	TGORef			;   yes
	BuildForward 0
	BuildForward 1
	BuildForward 2
	BuildForward 3
	BuildForward 4
	BuildForward 5
	BuildForward 6
	BuildForward 7
TGORet: ret
        
TGORef: BuildReverse 0
	BuildReverse 1
	BuildReverse 2
	BuildReverse 3
	BuildReverse 4
	BuildReverse 5
	BuildReverse 6
	BuildReverse 7
	ret
        

TGODifferent:				; Handle oddities.......
	movzx	esi,al
	jmp	[offset TGODiffTab + esi*2]

TGO3Close:				; 3 Copies,close @ 0,16,32
	call	TGOStd
	mov	al,TIAClock[bp]
	mov	ah,TIAReg[bp]
	mov	cx,ax
	add	al,16
	or	ah,64
	call	TIAInsert
	xchg	ax,cx
	add	al,32
	or	ah,64
	call	TIAInsert
	ret

TGO2Close:				; 2 copies seperated by 16 cycles
	call	TGOStd
	mov	al,TIAClock[bp]
	mov	ah,TIAReg[bp]
	add	al,16
	or	ah,64
	call	TIAInsert
	ret

TGO3Medium:				; 3 copies,medium @ 0,32,64
	call	TGOStd
	mov	al,TIAClock[bp]
	mov	ah,TIAReg[bp]
	mov	cx,ax
	add	al,32
	or	ah,64
	call	TIAInsert
	xchg	ax,cx
	add	al,64
	or	ah,64
	call	TIAInsert
	ret

TGO2Medium:				; 2 copies seperated by 32 cycles
	call	TGOStd
	mov	al,TIAClock[bp]
	mov	ah,TIAReg[bp]
	add	al,32
	or	ah,64
	call	TIAInsert
	ret

TGO2Far:			       ; 2 copies seperated by 64 cycles
	call	TGOStd
	mov	al,TIAClock[bp]
	mov	ah,TIAReg[bp]
	add	al,64
	or	ah,64
	call	TIAInsert
	ret


TGO2Width:
	cmp	ch,0			; do standard
	jz	TGORet			;   if zero, do nothing
	mov	al,ah
	test	cl,8			; reflected ?
	jnz	TGO2Ref			;   yes
	BuildForward2 0
	BuildForward2 1
	BuildForward2 2
	BuildForward2 3
	BuildForward2 4
	BuildForward2 5
	BuildForward2 6
	BuildForward2 7
	ret
        
TGO2Ref:
	BuildReverse2 0
	BuildReverse2 1
	BuildReverse2 2
	BuildReverse2 3
	BuildReverse2 4
	BuildReverse2 5
	BuildReverse2 6
	BuildReverse2 7
	ret

        
TGO4Width:
	cmp	ch,0			; do standard
	jz	TGORet			;   if zero, do nothing
	mov	al,ah
	push	ax
	shl	eax,16
	pop	ax
	test	cl,8			; reflected ?
	jnz	TGO4Ref			;   yes
	BuildForward4 0
	BuildForward4 1
	BuildForward4 2
	BuildForward4 3
	BuildForward4 4
	BuildForward4 5
	BuildForward4 6
	BuildForward4 7
	ret
        
TGO4Ref:
	BuildReverse4 0
	BuildReverse4 1
	BuildReverse4 2
	BuildReverse4 3
	BuildReverse4 4
	BuildReverse4 5
	BuildReverse4 6
	BuildReverse4 7
	ret

; *****************************************************************************
;
;     Insert all the objects (bl,p0,m0,p1,m1) from the last line at their
;     current positions as records <lastclock> <reg+128> 0 0. This will
;     cause them to be redrawn on the next line at the same position.
;     If an object is redrawn before they are reached they are invalidated.
;
; *****************************************************************************

TIAInsertObjects:
	mov	bx,TIAResp0		; bx - offset into TIA
TIAIOLoop:
	mov	al,TIA[bx]		; al is the clock value.
	mov	ah,bl			; bl is the register to write
	or	ah,128			; set bit 7,its a copied write
	call	TIAInsert		; insert the object.
	inc	bx			; go to the next object
	cmp	bx,TIAResbl		; Resbl is the last one.
	jle	TIAIOLoop
	ret

; *****************************************************************************
;
;		  Sort the TIA Buffer into Clock Order ....
;
; *****************************************************************************

TIASortBuffer:
	push	ax
	push	bx
	push	cx
	push	dx
	mov	al,TIAClock[bp]		; don't sort if 0 or 1 items
	cmp	al,TIAEnd
	je	TIASortExit
	mov	al,TIAClock+4[bp]
	cmp	al,TIAEnd
	je	TIASortExit
TIASortMain:
	mov	cl,0			; bl is set if any swaps this pass
	mov	bx,bp			; bx points into the table
TIASortLoop:
	mov	al,TIAClock[bx]		; get clocks of next 2 writes
	mov	ah,TIAClock+4[bx]
	cmp	al,ah			; if [first] <= [second] skip swap
	jbe	TIANoSwap

	mov	edx,[bx]		;do the swap
	mov	eax,4[bx]
	mov	[bx],eax
	mov	4[bx],edx

	inc	cl			; we've done a swap this pass.
TIANoSwap:
	add	bx,4			; go to next pair of writes
	mov	ah,TIAClock+4[bx]	; if there is one to swap with next...
	cmp	ah,TIAEnd
	jne	TIASortLoop		; then jump back

	cmp	cl,0			; have we swapped this time round
	jnz	TIASortMain		; yes,go back and sort again

TIASortExit:
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret


; *****************************************************************************
;
;	     Insert a record in the TIA Buffer (pointed to by BP)
;		    AL = Clock Value, AH = Register value
;
; *****************************************************************************

TIAInsert:
	push	bx
	push	cx
	push	bp
	push	ax			; this must be last...
        
TIAFindInsert:
	mov	bl,TIAClock[bp]		; bl is clock here
	add	bp,4
	cmp	al,bl			; try next if clock < insert clock
	jae	TIAFindInsert

	sub	bp,4
	push	bp			; save where the results go

	mov	ebx,[bp]		; 1st to carry forward
TIACarryForward:
	add	bp,4
	mov	ecx,[bp]		; next to carry forward
	mov	[bp],ebx		; save what was carried forward
	mov	bl,TIAClock[bp]
	cmp	bl,TIAEnd		; was the end marker carried forward
	je	TIAInsert2
	mov	ebx,ecx			; update the carry forward registers
	jmp	TIACarryForward

TIAInsert2:
	pop	bp
	pop	ax			; restore the data and address
	mov	TIAClock[bp],al
	mov	TIAReg[bp],ah
	xor	bl,bl
	mov	TIAVal[bp],bl		; zero out the value field

	pop	bp
	pop	cx
	pop	bx
        
	ret
